package com.beep_boop.Beep.levelSelect;

import java.util.ArrayList;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Point;
import android.graphics.PointF;
import android.graphics.RectF;
import android.util.AttributeSet;
import android.view.MotionEvent;

public class MapView
{
	///-----Interfaces-----
	public interface NodeClickListener
	{
		public void mapViewUserCanClickNode(MapView aMapView, MapNode aNode);
		public void mapViewUserDidClickNode(MapView aMapView, MapNode aNode);
	}
	
	public interface NodeStatusDataSource
	{
		public boolean mapViewIsNodeDone(MapView aMapView, MapNode aNode);
	}
	
	///-----Members-----
	/** Holds the listener who handles node clicks */
	private NodeClickListener mListener;
	/** Holds the data source */
	private NodeStatusDataSource mDataSource;

	/** Holds all the nodes on the map */
	private ArrayList<MapNode> mNodes;
	/** Holds the status of all the nodes */
	private ArrayList<Boolean> mNodeStates;
	/** Holds the currently selected node */
	private int mSelectedNode;

	/** Holds the view origin in map space */
	private PointF mOrigin;

	/** Holds the bounds the origin can take in map space */
	private RectF mOriginBounds;

	/** Holds the minimum distance the finger must move to be considered a scroll */
	private static final float mMinScrollDelta = 5.0f;
	/** Holds if we’re currently handling a touch */
	private boolean mTouched = false;
	/** Holds the starting point of a touch in screen coords */
	private Point mTouchStartPoint;
	/** Holds the last registered point of the touch in screen coords */
	private Point mTouchLastPoint;
	/** Holds whether or not we are scrolling */
	private boolean mScrolling; 
	/** Holds the maximum distance the finger can be from a node to click it*/
	private static final float mMaxNodeClickDistance = 10.0f;

	/** Holds the amount of the map on the screen width wise */
	private float mMapOnScreenWidth;
	/** Holds the amount of the map on the screen height wise */
	private float mMapOnScreenHeight;

	/** Hold the image to be drawn in the background */
	private Bitmap mBackgroundImage; // This may need to be broken up into multiple images, in which case an array should be used

	/** Holds the OFF node image */
	private Bitmap mNodeImageOff;
	/** Holds the ON node image */
	private Bitmap mNodeImageOn;
	/** Holds an overlay for the selected node  */
	private Bitmap mSelectedNodeOverlay;
	/** Holds the time it takes to transition between the off and on node image for the selected node */
	private static final float NODE_IMAGE_TRANSITION_TIME;
	/** Holds the current state of the node */
	private boolean mSelectedNodeState;
	/** Holds the time until the next swtich */
	private float mSelectedNodeTime;

	///-----Constructors-----
	public MapView(Context context, AttributeSet attrs)
	{
		
	}
	
	///-----Functions-----
	//Implements LevelDoneListener interface

	//sets the listener
	public void setListener(NodeClickListener aListener)
	{
		this.mListener = aListener;
	}
	
	//sets the data source
	public void setDataSource(NodeStatusDataSource aDataSource)
	{
		this.mDataSource = aDataSource;
	}

	//adds a node
	public void addNode(MapNode aNode)
	{
		this.mNodes.add(aNode);
	}
	
	//adds multiple nodes
	public void addNodes(ArrayList<MapNode> aNodeArray)
	{
		this.mNodes.addAll(aNodeArray);
	}
	
	//gets the state of a node from the DataSource
	private boolean getStateForNode(MapNode aNode)
	{
		return this.mDataSource.mapViewIsNodeDone(this, aNode);
	}

	//sets the selected node
	public void setSelectedNode(int aIndex)
	{
		this.mSelectedNode = aIndex;
	}

	//calculates the max and min origin bounds
	private void calculateOriginBounds()
	{
		//@TODO
	}
	
	//ensures the view’s origin is within the bounds
	private void boundOrigin()
	{
		//@TODO
	}
	
	//sets the origin of the view
	public void setOrigin(PointF aOrigin)
	{
		//@TODO
	}
	
	//centers the view on the node
	private void centerOnNode(int aIndex)
	{
		//@TODO
	}

	//overriden view method
	protected void onDraw(Canvas canvas)
	{
		//@TODO
	}
	
	//draws the background of the map
	private void drawBackground(Canvas canvas)
	{
		//@TODO
	}
	
	//draws all the nodes that are within the bounds of the screen
	private void drawNodesWithinView(Canvas canvas)
	{
		//@TODO
	}

	//handles scrolling
	private void scroll(float aX, float aY)
	{
		//@TODO
	}
	
	//tells the mapview to update all of the node’s states and redraw
	public void invalidate()
	{
		//@TODO
	}

	//gets touch events for view
	public boolean onTouchEvent(MotionEvent event)
	{
		//@TODO
	}

	//handles all touch moved events
	private void touchMoved(MotionEvent aEvent)
	{
		//@TODO
	}
	
	//increments the origin
	private void incrementOrigin(float aX, float aY)
	{
		//@TODO
	}

	//handles all touch up events
	private void touchUp(MotionEvent aEvent)
	{
		//check if we are scrolling
		if (this.mScrolling)
		{
			//if we are, then don't do anything but reset
			this.resetTouchVariables();
		}
		else
		{
			//if we're not, convert the touch point to map scace
			PointF mapSpace = this.convertToMapSpace(aEvent.getX(), aEvent.getY());
			
		}
	}
	
	//converts a point in touch space to map space
	private PointF convertToMapSpace(float aX, float aY)
	{
		//@TODO
	}
	
	//find a node near the location. If there isn’t a node, returns null
	private MapNode getNodeAtPoint(PointF aPoint)
	{
		MapNode result = null;
		for (MapNode node : this.mNodes)
		{
			double distance = Math.sqrt(Math.pow(aPoint.x - node.getX(), 2) + Math.pow(aPoint.y- node.getY(), 2));
			if (Math.abs(distance) <= MapView.mMaxNodeClickDistance)
			{
				result = node;
				break;
			}
		}
		
		return result;
	}
	
	//resets all touch variables
	private void resetTouchVariables()
	{
		//@TODO
	}

}
