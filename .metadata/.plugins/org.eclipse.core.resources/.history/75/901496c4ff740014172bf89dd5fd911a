package com.beep_boop.Beep.game;

import java.util.ArrayList;
import java.util.Set;

import android.animation.TimeAnimator;
import android.content.Context;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.PointF;
import android.graphics.Rect;
import android.util.AttributeSet;
import android.util.Log;
import android.view.MotionEvent;
import android.view.View;

import com.beep_boop.Beep.R;

public class PlayView extends View
{
	///-----Members-----
	/** Holds the tag used for logging */
	private static final String TAG = "PlayView";

	private PointF[] mDrawPoints;
	private float[] mDrawThetas;
	private int mStartWordIndex = 0;
	private int mNumberOfWordsToDraw = 10;
	private ArrayList<String> mWords = new ArrayList<String>();

	private PointF[] mStartPoints;
	private float[] mStartThetas;
	private float mAnimationPercent;
	private Paint mTextPaint = new Paint();

	/** Holds the minimum distance the finger must move to be considered a scroll */
	private static final float mMinScrollDelta = 5.0f;
	/** Holds the last registered point of the touch in screen coords */
	private PointF mLastTouchPoint = new PointF();
	/** Holds whether or not we are scrolling */
	private boolean mScrolling; 

	private static final float SCROLL_SCALAR = 0.05f;
	private static final float SCROLL_ACCELERATION = 0.000005f;
	private static final float SCROLL_VELOCITY_MIN = 0.000005f;
	private static final float SCROLL_VELOCITY_SCALAR = 100f;
	private float mScrollVelocity = 0.0f;
	private double mLastTouchTime;
	private TimeAnimator mScrollAnimator;
	private float mLastDeltaX, mLastDeltaY;

	///-----Constructors-----
	public PlayView(Context context, AttributeSet attrs)
	{
		super(context, attrs);

		TypedArray a = context.getTheme().obtainStyledAttributes(attrs, R.styleable.PlayView, 0, 0);
		try
		{

		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
		finally
		{
			a.recycle();
		}

		this.init();
	}

	private void init()
	{
		this.mTextPaint = new Paint();
		this.mTextPaint.setTextSize(20.0f);
		this.mTextPaint.setColor(0x000000);

		//does a circle pattern
		ArrayList<PointF> startPoints = new ArrayList<PointF>();
		ArrayList<Float> startThetas = new ArrayList<Float>();
		float delta = (float)Math.PI / (this.mNumberOfWordsToDraw + 1);
		float theta = (float)Math.PI/2;
		float radius = 0.5f;
		for (int i = 0; i < this.mNumberOfWordsToDraw + 1; i++,  theta -= delta)
		{
			startPoints.add(new PointF(radius * (float)Math.cos(theta), radius * (float)Math.sin(theta) + 0.5f));
			startThetas.add(theta);
		}
		this.setStarts(startPoints, startThetas);
		
		this.mScrollAnimator = new TimeAnimator();
		this.mScrollAnimator.setTimeListener(new TimeAnimator.TimeListener()
		{
			@Override
			public void onTimeUpdate(TimeAnimator animation, long totalTime, long deltaTime) {
				// TODO Auto-generated method stub
				scroll(mScrollVelocity * deltaTime);
				mScrollVelocity -= SCROLL_ACCELERATION * deltaTime;
				if (mScrollVelocity <= 0.0f)
				{
					mScrollVelocity = 0.0f;
				}
			}
		});
		this.mScrollAnimator.start();
	}
	
	@Override
	public void onDetachedFromWindow()
	{
		super.onDetachedFromWindow();
		
		//clean up the animator
		this.mScrollAnimator.cancel();
		this.mScrollAnimator = null;
	}

	public void setWords(Set<String> aWords)
	{
		if (aWords != null)
		{
			this.mWords.clear();
			this.mWords.addAll(aWords);
		}
	}

	///-----Functions-----
	//overridden view method
	@Override
	public void onDraw(Canvas canvas)
	{
		this.calculateDrawPointsAndThetas();
		for (int i = 0; i < mNumberOfWordsToDraw; i++)
		{
			if (mStartWordIndex + i < this.mWords.size() && mStartWordIndex + i >= 0)
			{
				float x = mDrawPoints[i].x;
				float y = mDrawPoints[i].y;

				mTextPaint.setColor(Color.BLACK);
				mTextPaint.setTextSize(60);
				String startWord = mWords.get(mStartWordIndex + i);

				Rect rect = new Rect();
				mTextPaint.getTextBounds(startWord, 0, startWord.length(), rect);
				//canvas.rotate(mDrawThetas[i], x + rect.exactCenterX(), y + rect.exactCenterY()); //this line was the culprit
				canvas.drawText(startWord, x, y, mTextPaint);
			}
			else if (mStartWordIndex + i >= this.mWords.size())
			{
				break;
			}
		}	
	}


	//draws the background of the map
	private void drawBackground(Canvas canvas)
	{

	}


	private void setStarts(ArrayList<PointF> aPoints, ArrayList<Float> aThetas)
	{
		this.mNumberOfWordsToDraw = aPoints.size() - 1;
		this.mStartPoints = new PointF[aPoints.size()];
		this.mStartThetas = new float[aThetas.size()];
		this.mDrawThetas = new float[aThetas.size()];
		this.mDrawPoints = new PointF[aPoints.size()];
		for (int i = 0; i < aPoints.size(); i++)
		{
			this.mStartPoints[i] = aPoints.get(i);
			this.mStartThetas[i] = aThetas.get(i);
		}
		this.calculateDrawPointsAndThetas();
	}

	private void calculateDrawPointsAndThetas()
	{
		for (int i = 0; i < this.mStartPoints.length - 1; i++)
		{
			PointF currentPoint = this.mStartPoints[i];
			PointF nextPoint = this.mStartPoints[i + 1];

			float deltaX = (nextPoint.x - currentPoint.x) * this.mAnimationPercent;
			float deltaY = (nextPoint.y - currentPoint.y) * this.mAnimationPercent;
			float deltaTheta = (this.mStartThetas[i + 1] - this.mStartThetas[i]) * this.mAnimationPercent;

			this.mDrawPoints[i] = new PointF(currentPoint.x + deltaX, currentPoint.y + deltaY);
			this.mDrawPoints[i].x *= this.getWidth();
			this.mDrawPoints[i].y *= this.getHeight();
			this.mDrawThetas[i] = (this.mDrawThetas[i] + deltaTheta)*180/(float)Math.PI;
		}
	}


	//gets touch events for view
	@Override
	public boolean onTouchEvent(MotionEvent event)
	{
		//result holds if the touch was processed by the view, which is all cases is yes
		boolean result = true;
		if (event.getAction() == MotionEvent.ACTION_DOWN)
		{
			//handle touch down
			this.touchDown(event);
		}
		else if (event.getAction() == MotionEvent.ACTION_MOVE)
		{
			//handle touch moved
			this.touchMoved(event);
		}
		else if (event.getAction() == MotionEvent.ACTION_UP)
		{
			//handle touch up
			this.touchUp(event);
		}
		else
		{
			Log.e(PlayView.TAG, "Unknown motion event type: " + event.getAction());
			result = false;
		}

		return result;
	}

	//handles all touch down events
	private void touchDown(MotionEvent aEvent)
	{
		this.mLastTouchPoint.x = aEvent.getX();
		this.mLastTouchPoint.y = aEvent.getY();
		
		this.mLastTouchTime = System.currentTimeMillis();
	}

	//handles all touch moved events
	private void touchMoved(MotionEvent aEvent)
	{
		float deltaX = aEvent.getX() - this.mLastTouchPoint.x;
		float deltaY = aEvent.getY() - this.mLastTouchPoint.y;

		//check if we are already scrolling
		if (this.mScrolling)
		{
			//increment the last touch point
			this.mLastTouchPoint.x += deltaX;
			this.mLastTouchPoint.y += deltaY;
			
			//increment the origin by the delta
			this.scroll(-deltaY * PlayView.SCROLL_SCALAR);
		}
		else
		{
			//check if we've exceeded the minimum scroll distance
			if (Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2)) >= Math.pow(PlayView.mMinScrollDelta, 2))
			{
				//if so, we are scrolling
				this.mScrolling = true;
			}
		}
		
		this.mLastDeltaX = deltaX;
		this.mLastDeltaY = deltaY;
	}

	private void scroll(float aIncrement)
	{
		//increment the percent
		this.mAnimationPercent += aIncrement;

		//bound the percent
		if (this.mAnimationPercent > 1.0f)
		{
			this.mAnimationPercent = 0;
			this.mStartWordIndex--;
			if (this.mStartWordIndex < -this.mWords.size())
			{
				this.mStartWordIndex = -this.mWords.size();
			}
		}
		else if (this.mAnimationPercent < 0.0f)
		{
			this.mAnimationPercent = 1;
			this.mStartWordIndex++;
			if (this.mStartWordIndex >= this.mWords.size())
			{
				this.mStartWordIndex = this.mWords.size();
			}
		}

		//calculate the draw points
		this.requestRedraw();
	}

	private void requestRedraw()
	{
		invalidate();
		requestLayout();
	}

	//handles all touch up events
	private void touchUp(MotionEvent aEvent)
	{
		//check if we are scrolling
		if (this.mScrolling)
		{
			//calculate the delta time
			double currentTime = System.currentTimeMillis();
			double deltaTime = currentTime - this.mLastTouchTime;
			this.mLastTouchTime = currentTime;
			//set the velocity
			float velocity = (float)(this.mLastDeltaY / deltaTime) * SCROLL_VELOCITY_SCALAR;;
			if (velocity > PlayView.SCROLL_VELOCITY_MIN)
			{
				this.mScrollVelocity = velocity;
			}
		}
		else
		{
			//@TODO - click
		}

		//touch ended, reset all variables
		this.resetTouchVariables();
	}

	//resets all touch variables
	private void resetTouchVariables()
	{
		//reset variables here as needed
		this.mScrolling = false;
		this.mLastTouchPoint = new PointF(-1.0f, -1.0f);
	}

}
